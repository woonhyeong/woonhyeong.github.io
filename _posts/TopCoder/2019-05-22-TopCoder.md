---
title: "탐색 범위 한정 알고리즘 - (2): StockHistory"
excerpt: "2019-05-22 TopCoder"
permalink: /til/:year/:month/:day/:title/
search: true
categories:
 - TopCoder
tags:
 - jekyll
toc: true
comments: true
last_modified_at: 2019-05-22
---

## 설명
> 개발환경
- Xcode 10.2
- C++14

---

# 문제

__StockHistory__  
정의  
 > public: vector<string> split(string str, char delimeter)  
 
제약조건  
 > initialInvestment : 0\~10000  
 monthlyContributon : 0\~1000  
 stockPrices : 2\~50개의 요소, 공백으로 나눠진 각각의 정수 값은 1\~999의 값  
 
---

# 코드

{% highlight cpp %}
{% raw %}
#include <string>
#include <vector>
#include <cmath>
#include <sstream>
using namespace std;

class StockHistory {
public:
    vector<string> split(string str, char delimeter) {
        vector<string> internal;
        stringstream ss(str);
        string temp;
        while (getline(ss, temp, delimeter)) {
            internal.push_back(temp);
        }
        return internal;
    }
    
    int maximumEarnings(int initialInvestment, int monthlyContribution, vector<string> stockPrices) {
        int stock[50][50];
        int slen = 0;
        
        // convert string of stockPrices to int value
        for (int i = 0; i < stockPrices.size(); i++) {
            string s = stockPrices[i];
            vector<string> sline = split(s,' ');
            
            for (slen = 0; slen < sline.size(); slen++) {
                stock[i][slen] = stoi(sline[slen]);
            }
        }
    
        bool buy[50] = {false,};
        double inc[50];
        double ans = 0.0;
        double cur_max = 0;
        int eidx = (int)stockPrices.size()-1;
        
        for (int i = eidx-1; i >= 0; i--) {
            for (int k = 0; k < slen; k++) {
                double p = 1.0*stock[eidx][k]/stock[i][k] - 1;
                
                if (0 < p && cur_max < p) {
                    buy[i] = true;
                    cur_max = p;
                    inc[i] = p;
                }
            }
        }
        
        int money = initialInvestment;
        for (int i = 0; i < stockPrices.size(); i++) {
            if (buy[i]) {
                ans += money*inc[i];
                money = 0;
            }
            money += monthlyContribution;
        }
        
        return (int)round(ans);
    }
};
{% endraw %}
{% endhighlight %}

--- 

# 해결전략

&nbsp; `그리디 알고리즘`을 이용하여 풀었다. 마지막 n월을 기준으로 n-1부터 비교해간다. n-1이 n월을 기준으로 증가했으면, `증가율`을 구해 inc[n-1]배열에 저장한다.  
그리고 n-2의 증가율을 구할 때, n월을 기준으로 증가하지 않았거나 이전 증가율보다 덜 증가했으면 구하지 않는다. 즉, 최대의 증가율이 있는 월에 monthlyContribution을 몰빵하는 것이다.  
증가율을 저장하는 inc배열과 그 월에 주식을 구매할지 결정하는 buy 배열에 저장한 데이터를 이용하여 마지막에 총 이익을 구했다.  

<br> &nbsp; 쉽다 생각하고 풀었었는데, 상당한 시간을 잡아먹었다. 가장 큰 이유는 문제에 대한 이해의 부족이였다.  
monthlyContribution이 사용하지 않으면 다음 월로 이전 가능한지 몰랐었다. 하지만, 다음 월로 이전이 불가능하다면 이 알고리즘은 그리디라고 할 수 없기에 크나 큰 실수였다.

---
